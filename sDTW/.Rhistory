<<<<<<< Updated upstream
n = 20L    # Number of data points to sample
signal = linear    # Type of reference signal
up = as.integer(n + n/2)    # Maximum length of test signal
down = as.integer(n - n/2)  # Minimum length of the test signal
m = sample(seq(down, up), size = 1)     # Length of the test signal
x = sample.custom(n)    # Standard sampling pattern
x.rand = sample.custom(m, random = T)   # Random sampling pattern
old.par <- par(mfrow = c(1, 2))
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
par(old.par)
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = square    # Type of reference signal
lay = matrix(c(1,3,2,3), ncol = 2)
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = sine    # Type of reference signal
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = cosine    # Type of reference signal
layout(lay)
x = sample.custom(n)    # Standard sampling pattern
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
library("dtw")
signal = linear
alignment.linear <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.linear, type = "two", match.indices = min(length(alignment.linear$index1), 50))
plot(alignment.linear, type = "three", match.indices = min(length(alignment.linear$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.linear$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.linear$index1, alignment.linear$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.linear$normalizedDistance ))
signal = square
alignment.square <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.square, type = "two", match.indices = min(length(alignment.square$index1), 50))
plot(alignment.square, type = "three", match.indices = min(length(alignment.square$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.square$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.square$index1, alignment.square$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.square$normalizedDistance ))
signal = sine
alignment.sine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.sine, type = "two", match.indices = min(length(alignment.sine$index1), 50))
plot(alignment.sine, type = "three", match.indices = min(length(alignment.sine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.sine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.sine$index1, alignment.sine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.sine$normalizedDistance ))
signal = cosine
alignment.cosine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.cosine, type = "two", match.indices = min(length(alignment.cosine$index1), 50))
plot(alignment.cosine, type = "three", match.indices = min(length(alignment.cosine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.cosine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.cosine$index1, alignment.cosine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.cosine$normalizedDistance ))
plot(alignment.linear$index1, alignment.linear$index2 + 1, col = "blue", type = "b", pch = 17, ylim = c(1, max(alignment.cosine$index2 + 5)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment.square$index1, alignment.square$index2 + 2, col = "red", type = "b", pch = 4)
lines(alignment.sine$index1, alignment.sine$index2 + 3, col = "green", type = "b", pch = 10)
lines(alignment.cosine$index1, alignment.cosine$index2 + 4, col = "purple", type = "b", pch = 15)
legend(max(alignment.linear$index1)*0.75, max(alignment.linear$index2)*0.5, legend=c("Linear", "Square (+1)", "Sine(+2)", "Cosine(+3)"), col = c("blue", "red", "green", "purple"), pch = c(17, 4, 10, 15), lty=1, cex=0.8)
if (!require("foreign")) install.packages("foreign")
library(foreign)  #Library to read .arff files
old.dir <- getwd()
setwd("C:/Users/DEPAGRA/Documents/Projects/Datasets/")
eeg <- read.arff("EEG Eye State.arff")
P8 <- ts(data = eeg$P8[1:500])  # Selecting the EEG channel P8, only the first 100 measurements
plot(P8, main = "EEG signal, channel P8", xlab = "Index of measurement", ylab = "mV")
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
m = sample(seq(n-n/2, n+n/2), size = 1)
x.rand = sort(sample(seq(1:n), size = m, replace = T))
test.signal.1 = ts(subsP8.1[x.rand])
test.signal.2 = ts(subsP8.2[x.rand])
yrange = c(min(min(test.signal.1), min(test.signal.2)), max(max(test.signal.1), max(test.signal.2)))
plot(test.signal.1, type = "b", ylim = yrange, col = "red")
lines(test.signal.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", main = "First chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.1, type = "b", ylim = yrange, col = "red4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("red", "red4"), lty = 1)
plot(subsP8.2, type = "b", ylim = yrange, col = "blue", main = "Second chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.2, type = "b", ylim = yrange, col = "lightblue4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("blue", "lightblue4"), lty = 1)
library(dtw)
alignment1 <- dtw(test.signal.1, subsP8.1, keep = T)
alignment2 <- dtw(test.signal.2, subsP8.2, keep = T)
plot(alignment1, type = "three")
plot(alignment2, type = "three")
plot(alignment1$index1, alignment1$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment2$index1, alignment2$index2+3, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
subsP8.1.fun = approxfun(subsP8.1)
subsP8.2.fun = approxfun(subsP8.2)
x.rand.cont = runif(n = m, min = 1, max = n)
plot(seq(1,n), seq(1,n), type = "b", col = "blue", pch = 17, xlab = "x", ylab = "")
lines(x.rand.cont, x.rand.cont, type = "p", col = "red", pch = 4, lwd = 2)
test.signal.1.cont = ts(subsP8.1.fun(x.rand.cont))
test.signal.2.cont = ts(subsP8.2.fun(x.rand.cont))
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", col = "red", main = "First Chunk", ylab = "Amplitude")
lines(test.signal.1.cont, type = "b")
plot(subsP8.2, type = "b", col = "blue", main = "Second Chunk", ylab = "")
lines(test.signal.2.cont, type = "b")
par(old.par)
alignment3 <- dtw(test.signal.1.cont, subsP8.1, keep = T)
alignment4 <- dtw(test.signal.2.cont, subsP8.2, keep = T)
plot(alignment3, type = "three")
plot(alignment4, type = "three")
plot(alignment3$index1, alignment3$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment4$index1, alignment4$index2, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
print("Number of sampled points: ", m)
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
print("Number of sampled points: ", m)
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
print("Number of sampled points: ")
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
print("Number of sampled points: ")
print(m)
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
knitr::opts_chunk$set(echo = TRUE)
set.seed(8)
linear <- function(x){
# Function to generate a linear signal in [0, 1]
return(x * (x >= 0 & x<= 1))
}
square <- function(x){
# Function to generate a square signal in [0, 1]
return(x^2 * (x >= 0 & x<= 1))
}
sine <- function(x){
# Function to generate a sinusoidal signal in [0, 1]
return(sin(x*2*pi) * (x >= 0 & x<= 1))
}
cosine <- function(x){
# Function to generate a cosinusoidal signal in [0, 1]
return(cos(x*2*pi) * (x >= 0 & x<= 1))
}
sample.custom <- function(n, random = FALSE){
# sample in [0, 1]. If random = TRUE, the samples are not evenly spaced
if (!random){
x = seq(0, 1, length.out = n)
}
else{
x = sort(runif(n))
}
return(x)
}
n = 20L    # Number of data points to sample
signal = linear    # Type of reference signal
up = as.integer(n + n/2)    # Maximum length of test signal
down = as.integer(n - n/2)  # Minimum length of the test signal
m = sample(seq(down, up), size = 1)     # Length of the test signal
x = sample.custom(n)    # Standard sampling pattern
x.rand = sample.custom(m, random = T)   # Random sampling pattern
old.par <- par(mfrow = c(1, 2))
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
par(old.par)
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = square    # Type of reference signal
lay = matrix(c(1,3,2,3), ncol = 2)
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = sine    # Type of reference signal
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = cosine    # Type of reference signal
layout(lay)
x = sample.custom(n)    # Standard sampling pattern
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
library("dtw")
signal = linear
alignment.linear <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.linear, type = "two", match.indices = min(length(alignment.linear$index1), 50))
plot(alignment.linear, type = "three", match.indices = min(length(alignment.linear$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.linear$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.linear$index1, alignment.linear$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.linear$normalizedDistance ))
signal = square
alignment.square <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.square, type = "two", match.indices = min(length(alignment.square$index1), 50))
plot(alignment.square, type = "three", match.indices = min(length(alignment.square$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.square$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.square$index1, alignment.square$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.square$normalizedDistance ))
signal = sine
alignment.sine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.sine, type = "two", match.indices = min(length(alignment.sine$index1), 50))
plot(alignment.sine, type = "three", match.indices = min(length(alignment.sine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.sine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.sine$index1, alignment.sine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.sine$normalizedDistance ))
signal = cosine
alignment.cosine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.cosine, type = "two", match.indices = min(length(alignment.cosine$index1), 50))
plot(alignment.cosine, type = "three", match.indices = min(length(alignment.cosine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.cosine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.cosine$index1, alignment.cosine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.cosine$normalizedDistance ))
plot(alignment.linear$index1, alignment.linear$index2 + 1, col = "blue", type = "b", pch = 17, ylim = c(1, max(alignment.cosine$index2 + 5)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment.square$index1, alignment.square$index2 + 2, col = "red", type = "b", pch = 4)
lines(alignment.sine$index1, alignment.sine$index2 + 3, col = "green", type = "b", pch = 10)
lines(alignment.cosine$index1, alignment.cosine$index2 + 4, col = "purple", type = "b", pch = 15)
legend(max(alignment.linear$index1)*0.75, max(alignment.linear$index2)*0.5, legend=c("Linear", "Square (+1)", "Sine(+2)", "Cosine(+3)"), col = c("blue", "red", "green", "purple"), pch = c(17, 4, 10, 15), lty=1, cex=0.8)
if (!require("foreign")) install.packages("foreign")
library(foreign)  #Library to read .arff files
old.dir <- getwd()
setwd("C:/Users/DEPAGRA/Documents/Projects/Datasets/")
eeg <- read.arff("EEG Eye State.arff")
P8 <- ts(data = eeg$P8[1:500])  # Selecting the EEG channel P8, only the first 100 measurements
plot(P8, main = "EEG signal, channel P8", xlab = "Index of measurement", ylab = "mV")
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
print("Number of sampled points: ")
print(m)
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
m = sample(seq(n-n/2, n+n/2), size = 1)
x.rand = sort(sample(seq(1:n), size = m, replace = T))
test.signal.1 = ts(subsP8.1[x.rand])
test.signal.2 = ts(subsP8.2[x.rand])
yrange = c(min(min(test.signal.1), min(test.signal.2)), max(max(test.signal.1), max(test.signal.2)))
plot(test.signal.1, type = "b", ylim = yrange, col = "red")
lines(test.signal.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", main = "First chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.1, type = "b", ylim = yrange, col = "red4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("red", "red4"), lty = 1)
plot(subsP8.2, type = "b", ylim = yrange, col = "blue", main = "Second chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.2, type = "b", ylim = yrange, col = "lightblue4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("blue", "lightblue4"), lty = 1)
library(dtw)
alignment1 <- dtw(test.signal.1, subsP8.1, keep = T)
alignment2 <- dtw(test.signal.2, subsP8.2, keep = T)
plot(alignment1, type = "three")
plot(alignment2, type = "three")
plot(alignment1$index1, alignment1$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment2$index1, alignment2$index2+3, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
subsP8.1.fun = approxfun(subsP8.1)
subsP8.2.fun = approxfun(subsP8.2)
x.rand.cont = runif(n = m, min = 1, max = n)
plot(seq(1,n), seq(1,n), type = "b", col = "blue", pch = 17, xlab = "x", ylab = "")
lines(x.rand.cont, x.rand.cont, type = "p", col = "red", pch = 4, lwd = 2)
test.signal.1.cont = ts(subsP8.1.fun(x.rand.cont))
test.signal.2.cont = ts(subsP8.2.fun(x.rand.cont))
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", col = "red", main = "First Chunk", ylab = "Amplitude")
lines(test.signal.1.cont, type = "b")
plot(subsP8.2, type = "b", col = "blue", main = "Second Chunk", ylab = "")
lines(test.signal.2.cont, type = "b")
par(old.par)
alignment3 <- dtw(test.signal.1.cont, subsP8.1, keep = T)
alignment4 <- dtw(test.signal.2.cont, subsP8.2, keep = T)
plot(alignment3, type = "three")
plot(alignment4, type = "three")
plot(alignment3$index1, alignment3$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment4$index1, alignment4$index2, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
library("dtw")
?stepPattern
?dtw
?ts
x = ts(seq(1,10))
y = ts(seq(2,15))
x = ts(seq(1,10))
y = ts(seq(2,15))
d = dist(x, y)
x = matrix(seq(1,10), nrow = 2, ncol = 5)
y = matrix(seq(1,10), nrow = 2, ncol = 5)
d = dist(x, y)
d
y = matrix(seq(1,10), nrow = 5, ncol = 2)
x = matrix(seq(1,10), nrow = 5, ncol = 2)
y = matrix(seq(1,10), nrow = 5, ncol = 2)
d = dist(x, y)
d
numBatches = 20
numPVs = 7
numPoints = 1000
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
d = dist(x,x)
source('~/.active-rstudio-document', echo=TRUE)
numBatches = 20
numPVs = 7
numPoints = 1000
reference = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
start = Sys.time()
query = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
D = dist(query, reference)
alignment = dtw(D, step.pattern = "symmetricP05")
source('~/.active-rstudio-document', echo=TRUE)
?dist
head(D)
type(D)
typeof(D)
classof(D)
class(D)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
D
?stepMatrix
??stepMatrix
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
ldist<-matrix(1,nrow=6,ncol=6);  # Matrix of ones
ldist[2,]<-0; ldist[,5]<-0;      # Mark a clear path of zeroes
ldist[2,5]<-.01;		 # Forcely cut the corner
ds<-dtw(ldist);			 # DTW with user-supplied local
#   cost matrix
da<-dtw(ldist,step=asymmetric);	 # Also compute the asymmetric
plot(ds$index1,ds$index2,pch=3); # Symmetric: alignment follows
#   the low-distance marked path
points(da$index1,da$index2,col="red");  # Asymmetric: visiting
#   1 is required twice
ds$distance;
da$distance;
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?stepPattern
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
queries[[1]]
queries[1]
source('~/.active-rstudio-document', echo=TRUE)
queries[[1]]
class(queries[1])
class(queries[[1]])
source('~/.active-rstudio-document', echo=TRUE)
query = queries[[1]]
D = dist(reference, query)
alignment = dtw(D, "symmetricP0")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?stepPattern
source('~/.active-rstudio-document', echo=TRUE)
stepPattern
dtw$stepPattern
source('~/.active-rstudio-document', echo=TRUE)
require('dtw')
print(symmetricP05)
plot(symmetric1)
?text
knitr::opts_chunk$set(echo = TRUE)
plot(symmetric1)
require("dtw")
plot(symmetric1)
text(-.5, 1, "P1")
text(-.5, 1, "P1")
plot(symmetric1)
text(-.5, 1, "P1")
plot(symmetric1)
text(-.5, 1, "P1")
plot(symmetric1)
require("dtw")
plot(symmetricP05)
print(symmetricP05)
a = matrix(c(1,2,3,4), nrow = 2)
b = matrix(c(0,1,5,6), nrow = 2)
a
b
min(a,b)
lapply(list(a,b), min)
plot(symmetric1)
?stepPattern
dtw::mvmStepPattern()
dtw
globalCostMatrix
dtw:::globalCostMatrix()
dtw:::globalCostMatrix
C_computeCM_Call
dtw:::C_computeCM_Call
source('~/.active-rstudio-document', echo=TRUE)
x = c(1,6,2,3,0,9,4,3,6,3)
y = c(1,3,4,9,8,2,1,5,7,3)
require(dtw)
alignment = dtw(x = x, y = y, step.pattern = symmetric1, keep.internals = TRUE)
ccm = alignment$costMatrix
image(x = 1:nrow(ccm), y = 1:ncol(ccm), ccm)
text(row(ccm), col(ccm), label = ccm)
library("dtw")
symmetricP05
library(dtw)
symmetric1
pgamma(0.1, 6,93.5)
30+3+16+8+114+60+4+23+30+105
qgamma(.975, 10, 393)
plotpost = function(y) {}
plotpost = function(y) {}
plotpost = function(y) {393^10*10/((393+y)^(10+1))}
plotpost(3)
curve(plotpost(x), from = 0, to = 120)
30+16+8+114+60+4+23+30+105
dataComplete = c(1024, 1045, 1025, 1133, 1038, 1097, 1081, 968, 1045, 1081, 1016, 1055, 957, 1079, 1104, 1082, 1021, 1100, 1056, 1079, 1087, 1126, 1716, 1335, 982, 1106, 1066, 1127, 1306, 1159, 940, 1324)
hist(dataComplete)
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
=======
annotations = list(
x = 1.13,
y = 1.05,
text = 'Cluster',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
pl
length(ms$assignment)
ms$assignment
table(ms$assignment)
length(table(ms$assignment))
# 3d plot of paths
axy <- list(
nticks = length(table(ms$assignment)),
range = c(1, length(table(ms$assignment))),title="Cluster"
)
pl = plot_ly(runtrack, x = ~lon, y = ~lat, z = ~clusterc,
marker = list(color = ~clusterc, colorscale = "Viridis",size=1)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Longitude'),
yaxis = list(title="Latitude"),
zaxis = axy),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Cluster',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
pl
hcurve = sqrt(ks::hlscv(runsession$cdensity))
mcurves=meanShift(runsession$cdensity,nNeighbors = 60,bandwidth = hcurve, epsilonCluster = 1e-1, kernelType = "NORMAL")
table(mcurves$assignment) # clusters and number of curves belonging to it
# 3d plot of paths
axy <- list(
nticks = length(table(ms$assignment)),
range = c(1, length(table(ms$assignment))),title="Cluster"
)
pl = plot_ly(runtrack, x = ~lon, y = ~lat, z = ~clusterc,
marker = list(color = ~clusterc, colorscale = "Viridis",size=1)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Longitude'),
yaxis = list(title="Latitude"),
zaxis = axy),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Cluster',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
pl
for (i in 1:60){
for(j in 1:length(runtrack$id)){
if(runtrack$id[j]==paste("run", i, sep ="_" )){
runtrack$clusterc[j] = mcurves$assignment[i]
}
}
}
# 3d plot of paths
axy <- list(
nticks = length(table(ms$assignment)),
range = c(1, length(table(ms$assignment))),title="Cluster"
)
pl = plot_ly(runtrack, x = ~lon, y = ~lat, z = ~clusterc,
marker = list(color = ~clusterc, colorscale = "Viridis",size=1)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Longitude'),
yaxis = list(title="Latitude"),
zaxis = axy),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Cluster',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
pl
# 3d plot of paths
axy <- list(
nticks = length(table(mcurves$assignment)),
range = c(1, length(table(mcurves$assignment))),title="Cluster"
)
pl = plot_ly(runtrack, x = ~lon, y = ~lat, z = ~clusterc,
marker = list(color = ~clusterc, colorscale = "Viridis",size=1)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Longitude'),
yaxis = list(title="Latitude"),
zaxis = axy),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Cluster',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
pl
mcurves$assignment
runsmall <- subset(runtrack, id %in% c("run_2"))
gp2 <- ggmap(myMapInD) + geom_path(data = runsmall,
aes(x = lon, y = lat, col = id),
size = 1.5, lineend = "round",
alpha = .6)
# Take a look
print(gp2)
runtrack[runtrack$id=="run_2"]
runtrack[runtrack$id=="run_2"]
runsession = runtrack[,c('id','cdensity')]
runsession = runtrack[,c('id','cdensity')]
runsession = runtrack[,c('id','cdensity')]
runsession = runtrack[,c('id','cdensity')]
#The libraries required are:
require(ggmap)
require(pracma)
require(MASS)
require(Rvcg)
require(rgl)
require(misc3d)
require(plotly)
require(RColorBrewer)
require(dplyr)
require(MeanShift)
require(meanShiftR)
require(sparr)
require(hdrcde)
require(doParallel)
require(foreach)
require(iterators)
require(knitr)
cores=detectCores()-1 #in order to use the pc while we run the code
registerDoParallel(cores)
load("trackme.RData")
# Map boundaries
myLocation <- c(min(runtrack$lon, na.rm = T),
min(runtrack$lat, na.rm = T),
max(runtrack$lon, na.rm = T),
max(runtrack$lat, na.rm = T))
# Get the map from Google (default)
myMapInD <- get_map(location = myLocation, maptype = "roadmap", zoom = 13)
# Plot gps coordinates (without elevation data)
gp <- ggmap(myMapInD) + geom_point(data = runtrack,
aes(x = lon, y = lat),
size = .5, colour = I("red"), alpha = .01)
# Take a look
print(gp)
#The libraries required are:
require(ggmap)
require(pracma)
require(MASS)
require(Rvcg)
require(rgl)
require(misc3d)
require(plotly)
require(RColorBrewer)
require(dplyr)
require(MeanShift)
require(meanShiftR)
require(sparr)
require(hdrcde)
require(doParallel)
require(foreach)
require(iterators)
require(knitr)
cores=detectCores()-1 #in order to use the pc while we run the code
registerDoParallel(cores)
load("trackme.RData")
# Map boundaries
myLocation <- c(min(runtrack$lon, na.rm = T),
min(runtrack$lat, na.rm = T),
max(runtrack$lon, na.rm = T),
max(runtrack$lat, na.rm = T))
# Get the map from Google (default)
myMapInD <- get_map(location = myLocation, maptype = "roadmap", zoom = 13)
#The libraries required are:
require(ggmap)
require(pracma)
require(MASS)
require(Rvcg)
require(rgl)
require(misc3d)
require(plotly)
require(RColorBrewer)
require(dplyr)
require(MeanShift)
require(meanShiftR)
require(sparr)
require(hdrcde)
require(doParallel)
require(foreach)
require(iterators)
require(knitr)
cores=detectCores()-1 #in order to use the pc while we run the code
registerDoParallel(cores)
load("trackme.RData")
# Map boundaries
myLocation <- c(min(runtrack$lon, na.rm = T),
min(runtrack$lat, na.rm = T),
max(runtrack$lon, na.rm = T),
max(runtrack$lat, na.rm = T))
# Get the map from Google (default)
myMapInD <- get_map(location = myLocation, maptype = "roadmap", zoom = 13)
# Plot gps coordinates (without elevation data)
gp <- ggmap(myMapInD) + geom_point(data = runtrack,
aes(x = lon, y = lat),
size = .5, colour = I("red"), alpha = .01)
# Take a look
print(gp)
# x is a dataframe containing only the relevant information needed for this plot (latitude-longitude values)
x = subset(runtrack,select=c(lon,lat))
#finding a good value for the bandwidth h:
h1 = sqrt(diag(ks::Hpi(x,deriv.order=1))) # Plug-in bandwidth estimator
h2 = sqrt(diag(ks::Hlscv(x, deriv.order=1))) # Least Square cross validation
#estimate
density_estimate=kde2d(runtrack$lon, runtrack$lat,h=h2, n = 60, lims = c(range(runtrack$lon), range(runtrack$lat)))
#visualize
myMapInD <- get_map(location = myLocation, maptype = "roadmap", zoom = 13)
gg=ggmap(myMapInD)+
geom_density2d(data = runtrack, aes(x = lon, y = lat)) +  #display the results with contours.
stat_density2d(data = runtrack, aes(x = lon, y = lat, fill = ..level.., alpha=..level..),size = 0.02, bins = 16, geom = 'polygon')+
scale_fill_gradient(low = "green", high = "red") +
scale_alpha(range = c(0.2, 0.5), guide = FALSE)+
ggtitle("Level map")
print(gg)
x=subset(runtrack,select=c(lon,lat))
dcols <- densCols(x,colramp = colorRampPalette(brewer.pal(6, "YlOrRd")))
graphics::plot(x, col = dcols, pch = 20, main = "Color density Scatterplot")
p <- plot_ly(x = density_estimate$x, y = density_estimate$y, z = density_estimate$z) %>% add_surface()
p
# high density region information
hdrinfo <- hdr.2d(runtrack$lon,runtrack$lat,den=density_estimate, h = h2)
#hdr plot
plot.hdr2d(hdrinfo,shaded = TRUE, show.points = FALSE, xlab = "Lon", ylab = "Lat", main = "Plot HDR")
paste0("Longitude: ", round(hdrinfo$mode[1],3), "  Latitude: ", round(hdrinfo$mode[2],3))
X=as.matrix(x)
ms =meanShift(X,nNeighbors = 5000,bandwidth = h2, epsilonCluster = 1e-7, kernelType = "NORMAL")
table(ms$assignment)
plot(runtrack$lon, runtrack$lat, col = ms$assignment, cex = 0.2,xlab = "Lon",ylab="Lat")
legend("bottom",legend=unique(ms$assignment),col=1:length(ms$assignment),pch=1,lwd=2,xpd = TRUE, horiz = TRUE, inset = c(0.2,-0.2))
dist = rep(NA,1800)
c = 0
for(i in 1:60){
for (j in i:60) {
dist[c] = hausdorff_dist(
P = as.matrix(subset(runtrack, id == paste("run", i, sep ="_" ), select = -c(ele, time, id))),
Q = as.matrix(subset(runtrack, id == paste("run", j, sep ="_" ), select = -c(ele, time, id))))
c=c+1
}
}
# setting epsilon as the 0.25 quantile of the distances found
eps = quantile(dist, probs = 0.25)
matr = foreach ( i = 1:60, .packages = "pracma", .combine = cbind) %dopar% {
vett = rep(0, 60)
for ( j in 1:60){
d = hausdorff_dist(
P = as.matrix(subset(runtrack, id == paste("run", i, sep ="_" ), select = -c(ele, time, id))),
Q = as.matrix(subset(runtrack, id == paste("run", j, sep ="_" ), select = -c(ele, time, id))))
if(d<eps){
vett[j] = 1/60
}
}
vett
}
cdensity = colSums(matr, na.rm = TRUE) # density vector
for(i in 1:60){
for(j in 1:length(runtrack$id)){
if(runtrack$id[j]==paste("run", i, sep ="_" )){
runtrack$cdensity[j] = cdensity[i]
}
}
}
# 3d kernel density
kd3 = misc3d::kde3d(x = runtrack$lon, y = runtrack$lat, runtrack$cdensity)
# 3d plot of paths
pl = plot_ly(runtrack, x = ~lon, y = ~lat, z = ~cdensity,
marker = list(color = ~cdensity, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE,size=0.5)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Longitude'),
yaxis = list(title = 'Latitude'),
zaxis = list(title = 'Density')),
annotations = list(
x = 1.13,
y = 1.05,
text = 'Density per path',
xref = 'paper',
yref = 'paper',
showarrow = FALSE
))
pl
runsession = runtrack[,c('id','cdensity')]
runsession = distinct(runsession) # dataframe with id_run and the corresponding density
top5=top_n(runsession, 5, cdensity)
kable(top5[order(top5$cdensity, decreasing =T),], row.names = FALSE,caption="Top 5")
bottom5=top_n(runsession, 5,- cdensity)
kable(bottom5[order(bottom5$cdensity, decreasing =F),], format="markdown", row.names = FALSE,caption="Bottom 5"))
runsession = runtrack[,c('id','cdensity')]
runsession = distinct(runsession) # dataframe with id_run and the corresponding density
top5=top_n(runsession, 5, cdensity)
kable(top5[order(top5$cdensity, decreasing =T),], row.names = FALSE,caption="Top 5")
bottom5=top_n(runsession, 5,- cdensity)
kable(bottom5[order(bottom5$cdensity, decreasing =F),], format="html", row.names = FALSE,caption="Bottom 5"))
kable(bottom5[order(bottom5$cdensity, decreasing =F),], format="html", row.names = FALSE,caption="Bottom 5"))
bottom5=top_n(runsession, 5,- cdensity)
runsession = runtrack[,c('id','cdensity')]
runsession = distinct(runsession) # dataframe with id_run and the corresponding density
top5=top_n(runsession, 5, cdensity)
kable(top5[order(top5$cdensity, decreasing =T),], row.names = FALSE,caption="Top 5")
bottom5=top_n(runsession, 5,- cdensity)
kable(bottom5[order(bottom5$cdensity, decreasing =F),], row.names = FALSE,caption="Bottom 5"))
kable(top5[order(top5$cdensity, decreasing =T),], row.names = FALSE,caption="Top 5")
runsession = runtrack[,c('id','cdensity')]
runsession = distinct(runsession) # dataframe with id_run and the corresponding density
top5=top_n(runsession, 5, cdensity)
kable(top5[order(top5$cdensity, decreasing =T),], row.names = FALSE,caption="Top 5")
bottom5=top_n(runsession, 5,- cdensity)
kable(bottom5[order(bottom5$cdensity, decreasing =F),], row.names = FALSE,caption="Bottom 5"))
runsession = runtrack[,c('id','cdensity')]
runsession = distinct(runsession) # dataframe with id_run and the corresponding density
top5=top_n(runsession, 5, cdensity)
kable(top5[order(top5$cdensity, decreasing =T),], row.names = FALSE,caption="Top 5")
bottom5=top_n(runsession, 5,- cdensity)
kable(bottom5[order(bottom5$cdensity, decreasing =F),], row.names = FALSE,caption="Bottom 5")
rbin(100)
?rber
rbinom(5)
?rbinom
rbinom(x,5)
theta=seq(0,1,0.1)
theta=seq(0,1,0.1)
y=rbin(x,100)
y=rbinom(x,100)
?rbern
y=rbinom(x,100,prob=theta)
?runif
rbinom(10,1,0.5)
y=rbinom(100,1,prob=theta)
?pbinom
pbinom(47,100,0.1)
pbinom(47,100,0.1)
dbinom(47,100,0.1)
dbinom(47,100,0.9)
dbinom(47,100,prob=0.5)
dbinom(47,100,prob=0.47)
dbinom(47,100,prob=0.47)
pbinom(47,100,prob=0.47)
pbinom(47,100,prob=0.47)
pbinom(47,100,prob=0)
pbinom(47,100,prob=1)
pbinom(100,100,prob=1)
pbinom(100,100,prob=0)
pbinom(100,size=100,prob=0)
dbinom(100,size=100,prob=0)
dbinom(100,size=100,prob=1)
dbinom(57,size=100,prob=0.57)
rbinom(57,size=10,prob=0.57)
rbinom(57,n=2,size=10,prob=0.57)
rbinom1,n=2,size=10,prob=0.57)
rbinom(2,n=2,size=10,prob=0.57)
rbinom(1,n=2,size=10,prob=0.57)
rbinom(1,n=2,size=1,prob=0.57)
rbinom(100,1,0.5)
dbinom(57,size=1,prob=0.57)
pbinom(57,size=1,prob=0.57)
pbinom(1,size=1,prob=0.57)
pbinom(1,size=1,prob=0.57)
dbinom(1,size=2,prob=0.57)
rbinom(100,2,0.5)
dbinom(1,size=1,prob=1)
dbinom(1,size=1,prob=0)
pbinom(1,size=1,prob=0)
dbinom(2,size=1,prob=1)
rbinom(100,1,0.5)
rbinom(100,2,0.5)
rbinom(1,100,0.5)
dbinom(100,size=100,prob=1)
dbinom(100,size=100,prob=0)
dbinom(57,size=100,prob=0.57)
pbinom(57,size=100,prob=0.57)
pbinom(100,size=100,prob=1)
pbinom(100,size=100,prob=0)
y_sum=rbinom(1,100,prob=theta)
y_sum
y_sum=rbinom(1,100,prob=theta)
y_sum
y_sum=rbinom(1,100,prob=theta[2])
y_sum
rbinom(1,100,prob=1)
rbinom(1,100,prob=0)
pbinom(100,size=100,prob=0)
pbinom(100,size=100,prob=1)
dbinom(100,size=100,prob=1)
dbinom(100,size=100,prob=0)
1:11
for (i in theta){
print(i)
}
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=dbinom(100,size=100,prob=theta[i])
}
plot(prob)
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=dbinom(57,size=100,prob=theta[i])
}
plot(prob)
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=pbinom(57,size=100,prob=theta[i])
}
plot(prob)
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=dbinom(57,size=100,prob=theta[i])
}
plot(prob)
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=1-pbinom(57,size=100,prob=theta[i])
}
plot(prob)
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=pbinom(57,size=100,prob=theta[i])
}
plot(prob)
theta=seq(0,1,0.1)
y_sum=rbinom(1,100,prob=theta)
dbinom(100,size=100,prob=0)
prob=rep(NA,11)
for (i in seq(1,11)){
prob[i]=dbinom(57,size=100,prob=theta[i])
}
plot(prob)
?dgamma
set.seed(123)
psim=rpois(n = 10,lambda = 2)
#prior gamma
prior=function(theta){dgamma(theta,1,1)}
theta <- rgamma(n = 1000, 1, 1)
f_X_theta <- rpois(n = 1000, theta)
density(f_X_theta)
curve(density(f_X_theta))
plot(f_X_theta)
hist(f_X_theta)
hist(f_X_theta/1000)
hist(f_X_theta, probability = T)
?density
plot(density(f_X_theta))
f_X_theta <- rpois(lambda = theta)
f_X_theta <- rpois(10, lambda = theta)
f_X_theta <- rpois(theta, lambda = theta)
plot(density(f_X_theta))
knitr::opts_chunk$set(echo = TRUE)
install.packages("dtw")
install.packages("dtw")
library("dtw")
ref <- as.ts(seq(1:100))
test <- as.ts(c(seq(1:50), rep(50,5), seq(51:100)))
alignment <- dtw(ref, test, keep = T)
plot(alignment, type = "two", off = 10, match.indices = 50)
install.packages("dtw")
library("dtw")
ref <- as.ts(seq(1:100))
test <- as.ts(c(seq(1:50), rep(50,5), seq(51:100)))
alignment <- dtw(test, ref, keep = T)
plot(alignment, type = "two", off = 10, match.indices = 50)
install.packages("dtw")
test
# install.packages("dtw")
library("dtw")
ref <- as.ts(seq(1:100))
test <- as.ts(c(seq(1:50), rep(50,5), seq(51,100)))
alignment <- dtw(test, ref, keep = T)
plot(alignment, type = "two", off = 10, match.indices = 50)
# install.packages("dtw")
library("dtw")
ref <- as.ts(seq(1:100))
test <- as.ts(c(seq(1:50), rep(50,5), seq(51,100)))
alignment <- dtw(test, ref, keep = T)
par(mfrow = c(1,2))
plot(alignment, type = "two", off = 10, match.indices = 50)
plot(alignment$index1, alignment$index2)
?polr
??polr
setwd("~/GitHub/pgdtw/sDTW")
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
install.packages("Hmisc")
>>>>>>> Stashed changes
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
