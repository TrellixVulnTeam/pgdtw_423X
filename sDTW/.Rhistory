n = 20L    # Number of data points to sample
signal = linear    # Type of reference signal
up = as.integer(n + n/2)    # Maximum length of test signal
down = as.integer(n - n/2)  # Minimum length of the test signal
m = sample(seq(down, up), size = 1)     # Length of the test signal
x = sample.custom(n)    # Standard sampling pattern
x.rand = sample.custom(m, random = T)   # Random sampling pattern
old.par <- par(mfrow = c(1, 2))
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
par(old.par)
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = square    # Type of reference signal
lay = matrix(c(1,3,2,3), ncol = 2)
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = sine    # Type of reference signal
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = cosine    # Type of reference signal
layout(lay)
x = sample.custom(n)    # Standard sampling pattern
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
library("dtw")
signal = linear
alignment.linear <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.linear, type = "two", match.indices = min(length(alignment.linear$index1), 50))
plot(alignment.linear, type = "three", match.indices = min(length(alignment.linear$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.linear$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.linear$index1, alignment.linear$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.linear$normalizedDistance ))
signal = square
alignment.square <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.square, type = "two", match.indices = min(length(alignment.square$index1), 50))
plot(alignment.square, type = "three", match.indices = min(length(alignment.square$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.square$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.square$index1, alignment.square$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.square$normalizedDistance ))
signal = sine
alignment.sine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.sine, type = "two", match.indices = min(length(alignment.sine$index1), 50))
plot(alignment.sine, type = "three", match.indices = min(length(alignment.sine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.sine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.sine$index1, alignment.sine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.sine$normalizedDistance ))
signal = cosine
alignment.cosine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.cosine, type = "two", match.indices = min(length(alignment.cosine$index1), 50))
plot(alignment.cosine, type = "three", match.indices = min(length(alignment.cosine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.cosine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.cosine$index1, alignment.cosine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.cosine$normalizedDistance ))
plot(alignment.linear$index1, alignment.linear$index2 + 1, col = "blue", type = "b", pch = 17, ylim = c(1, max(alignment.cosine$index2 + 5)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment.square$index1, alignment.square$index2 + 2, col = "red", type = "b", pch = 4)
lines(alignment.sine$index1, alignment.sine$index2 + 3, col = "green", type = "b", pch = 10)
lines(alignment.cosine$index1, alignment.cosine$index2 + 4, col = "purple", type = "b", pch = 15)
legend(max(alignment.linear$index1)*0.75, max(alignment.linear$index2)*0.5, legend=c("Linear", "Square (+1)", "Sine(+2)", "Cosine(+3)"), col = c("blue", "red", "green", "purple"), pch = c(17, 4, 10, 15), lty=1, cex=0.8)
if (!require("foreign")) install.packages("foreign")
library(foreign)  #Library to read .arff files
old.dir <- getwd()
setwd("C:/Users/DEPAGRA/Documents/Projects/Datasets/")
eeg <- read.arff("EEG Eye State.arff")
P8 <- ts(data = eeg$P8[1:500])  # Selecting the EEG channel P8, only the first 100 measurements
plot(P8, main = "EEG signal, channel P8", xlab = "Index of measurement", ylab = "mV")
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
m = sample(seq(n-n/2, n+n/2), size = 1)
x.rand = sort(sample(seq(1:n), size = m, replace = T))
test.signal.1 = ts(subsP8.1[x.rand])
test.signal.2 = ts(subsP8.2[x.rand])
yrange = c(min(min(test.signal.1), min(test.signal.2)), max(max(test.signal.1), max(test.signal.2)))
plot(test.signal.1, type = "b", ylim = yrange, col = "red")
lines(test.signal.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", main = "First chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.1, type = "b", ylim = yrange, col = "red4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("red", "red4"), lty = 1)
plot(subsP8.2, type = "b", ylim = yrange, col = "blue", main = "Second chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.2, type = "b", ylim = yrange, col = "lightblue4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("blue", "lightblue4"), lty = 1)
library(dtw)
alignment1 <- dtw(test.signal.1, subsP8.1, keep = T)
alignment2 <- dtw(test.signal.2, subsP8.2, keep = T)
plot(alignment1, type = "three")
plot(alignment2, type = "three")
plot(alignment1$index1, alignment1$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment2$index1, alignment2$index2+3, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
subsP8.1.fun = approxfun(subsP8.1)
subsP8.2.fun = approxfun(subsP8.2)
x.rand.cont = runif(n = m, min = 1, max = n)
plot(seq(1,n), seq(1,n), type = "b", col = "blue", pch = 17, xlab = "x", ylab = "")
lines(x.rand.cont, x.rand.cont, type = "p", col = "red", pch = 4, lwd = 2)
test.signal.1.cont = ts(subsP8.1.fun(x.rand.cont))
test.signal.2.cont = ts(subsP8.2.fun(x.rand.cont))
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", col = "red", main = "First Chunk", ylab = "Amplitude")
lines(test.signal.1.cont, type = "b")
plot(subsP8.2, type = "b", col = "blue", main = "Second Chunk", ylab = "")
lines(test.signal.2.cont, type = "b")
par(old.par)
alignment3 <- dtw(test.signal.1.cont, subsP8.1, keep = T)
alignment4 <- dtw(test.signal.2.cont, subsP8.2, keep = T)
plot(alignment3, type = "three")
plot(alignment4, type = "three")
plot(alignment3$index1, alignment3$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment4$index1, alignment4$index2, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
print("Number of sampled points: ", m)
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
print("Number of sampled points: ", m)
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
print("Number of sampled points: ")
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
print("Number of sampled points: ")
print(m)
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
knitr::opts_chunk$set(echo = TRUE)
set.seed(8)
linear <- function(x){
# Function to generate a linear signal in [0, 1]
return(x * (x >= 0 & x<= 1))
}
square <- function(x){
# Function to generate a square signal in [0, 1]
return(x^2 * (x >= 0 & x<= 1))
}
sine <- function(x){
# Function to generate a sinusoidal signal in [0, 1]
return(sin(x*2*pi) * (x >= 0 & x<= 1))
}
cosine <- function(x){
# Function to generate a cosinusoidal signal in [0, 1]
return(cos(x*2*pi) * (x >= 0 & x<= 1))
}
sample.custom <- function(n, random = FALSE){
# sample in [0, 1]. If random = TRUE, the samples are not evenly spaced
if (!random){
x = seq(0, 1, length.out = n)
}
else{
x = sort(runif(n))
}
return(x)
}
n = 20L    # Number of data points to sample
signal = linear    # Type of reference signal
up = as.integer(n + n/2)    # Maximum length of test signal
down = as.integer(n - n/2)  # Minimum length of the test signal
m = sample(seq(down, up), size = 1)     # Length of the test signal
x = sample.custom(n)    # Standard sampling pattern
x.rand = sample.custom(m, random = T)   # Random sampling pattern
old.par <- par(mfrow = c(1, 2))
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
par(old.par)
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = square    # Type of reference signal
lay = matrix(c(1,3,2,3), ncol = 2)
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(0,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(0,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = sine    # Type of reference signal
layout(lay)
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
signal = cosine    # Type of reference signal
layout(lay)
x = sample.custom(n)    # Standard sampling pattern
plot(signal(x), main = "Signal with uniform sample rate", ylab = "Amplitude of reference signal", ylim = c(-1,1), type = "b")
plot(signal(x.rand), main = "Signal with non-uniform sample rate", ylab = "Amplitude of test signal", ylim = c(-1,1), type = "b")
plot(x, x, pch = 17, type = "b", col = "blue", main = "Sampling Patterns", ylab = "")
lines(x.rand, x.rand, type = "p", pch = 4, col = "red", lwd = 2)
legend(.7, .5, legend=c("Standard sampling", "Random sampling"), col = c("blue", "red"), pch = c(17, 4), lty=1, lwd = c(1, 2), cex=0.8)
text(.7, c(.2, .1), labels = c(paste("Number of points in the random sample: ", m), paste("Number of points in the standard sample: ", n)))
library("dtw")
signal = linear
alignment.linear <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.linear, type = "two", match.indices = min(length(alignment.linear$index1), 50))
plot(alignment.linear, type = "three", match.indices = min(length(alignment.linear$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.linear$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.linear$index1, alignment.linear$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.linear$normalizedDistance ))
signal = square
alignment.square <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.square, type = "two", match.indices = min(length(alignment.square$index1), 50))
plot(alignment.square, type = "three", match.indices = min(length(alignment.square$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.square$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.square$index1, alignment.square$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.square$normalizedDistance ))
signal = sine
alignment.sine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.sine, type = "two", match.indices = min(length(alignment.sine$index1), 50))
plot(alignment.sine, type = "three", match.indices = min(length(alignment.sine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.sine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.sine$index1, alignment.sine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.sine$normalizedDistance ))
signal = cosine
alignment.cosine <- dtw(signal(x.rand), signal(x), keep = T)
plot(alignment.cosine, type = "two", match.indices = min(length(alignment.cosine$index1), 50))
plot(alignment.cosine, type = "three", match.indices = min(length(alignment.cosine$index1), 50))
if (n <= 15 & T){
lcm <- round(alignment.cosine$localCostMatrix, 2)
image(x = 1:nrow(lcm), y = 1:ncol(lcm), lcm, xlab = "Test signal index", ylab = "Reference signal index")
text(row(lcm), col(lcm), label = lcm)
lines(alignment.cosine$index1, alignment.cosine$index2, lwd = 2)
}
print(c("Normalized distance" = alignment.cosine$normalizedDistance ))
plot(alignment.linear$index1, alignment.linear$index2 + 1, col = "blue", type = "b", pch = 17, ylim = c(1, max(alignment.cosine$index2 + 5)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment.square$index1, alignment.square$index2 + 2, col = "red", type = "b", pch = 4)
lines(alignment.sine$index1, alignment.sine$index2 + 3, col = "green", type = "b", pch = 10)
lines(alignment.cosine$index1, alignment.cosine$index2 + 4, col = "purple", type = "b", pch = 15)
legend(max(alignment.linear$index1)*0.75, max(alignment.linear$index2)*0.5, legend=c("Linear", "Square (+1)", "Sine(+2)", "Cosine(+3)"), col = c("blue", "red", "green", "purple"), pch = c(17, 4, 10, 15), lty=1, cex=0.8)
if (!require("foreign")) install.packages("foreign")
library(foreign)  #Library to read .arff files
old.dir <- getwd()
setwd("C:/Users/DEPAGRA/Documents/Projects/Datasets/")
eeg <- read.arff("EEG Eye State.arff")
P8 <- ts(data = eeg$P8[1:500])  # Selecting the EEG channel P8, only the first 100 measurements
plot(P8, main = "EEG signal, channel P8", xlab = "Index of measurement", ylab = "mV")
n = 20L # length of reference signal
shift = 5
s = max(1, min(shift, floor(length(P8)/n)-1))
subsP8.1 <- ts(P8[1:n])
subsP8.2 <- ts(P8[(s*n+1):((s+1)*n)])
print("Number of sampled points: ")
print(m)
old.par = par(xpd = T)
yrange = c(min(min(subsP8.1), min(subsP8.2)), max(max(subsP8.1), max(subsP8.2)))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", ylab = "Amplitude")
lines(subsP8.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
par(old.par)
m = sample(seq(n-n/2, n+n/2), size = 1)
x.rand = sort(sample(seq(1:n), size = m, replace = T))
test.signal.1 = ts(subsP8.1[x.rand])
test.signal.2 = ts(subsP8.2[x.rand])
yrange = c(min(min(test.signal.1), min(test.signal.2)), max(max(test.signal.1), max(test.signal.2)))
plot(test.signal.1, type = "b", ylim = yrange, col = "red")
lines(test.signal.2, type = "b", ylim = yrange, col = "blue")
legend("topright",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), fill = ,lty = 1)
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", ylim = yrange, col = "red", main = "First chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.1, type = "b", ylim = yrange, col = "red4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("red", "red4"), lty = 1)
plot(subsP8.2, type = "b", ylim = yrange, col = "blue", main = "Second chunk", xlim = c(1,max(n,m)), ylab = "")
lines(test.signal.2, type = "b", ylim = yrange, col = "lightblue4")
legend("topright",inset = c(0,0), legend = c("Reference signal", "Test signal"), col = c("blue", "lightblue4"), lty = 1)
library(dtw)
alignment1 <- dtw(test.signal.1, subsP8.1, keep = T)
alignment2 <- dtw(test.signal.2, subsP8.2, keep = T)
plot(alignment1, type = "three")
plot(alignment2, type = "three")
plot(alignment1$index1, alignment1$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment2$index1, alignment2$index2+3, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
subsP8.1.fun = approxfun(subsP8.1)
subsP8.2.fun = approxfun(subsP8.2)
x.rand.cont = runif(n = m, min = 1, max = n)
plot(seq(1,n), seq(1,n), type = "b", col = "blue", pch = 17, xlab = "x", ylab = "")
lines(x.rand.cont, x.rand.cont, type = "p", col = "red", pch = 4, lwd = 2)
test.signal.1.cont = ts(subsP8.1.fun(x.rand.cont))
test.signal.2.cont = ts(subsP8.2.fun(x.rand.cont))
old.par = par(mfrow = c(1,2))
plot(subsP8.1, type = "b", col = "red", main = "First Chunk", ylab = "Amplitude")
lines(test.signal.1.cont, type = "b")
plot(subsP8.2, type = "b", col = "blue", main = "Second Chunk", ylab = "")
lines(test.signal.2.cont, type = "b")
par(old.par)
alignment3 <- dtw(test.signal.1.cont, subsP8.1, keep = T)
alignment4 <- dtw(test.signal.2.cont, subsP8.2, keep = T)
plot(alignment3, type = "three")
plot(alignment4, type = "three")
plot(alignment3$index1, alignment3$index2, type = "b", col = "red", ylim = c(1, max(alignment2$index2+3)), xlab = "Test signal index", ylab = "Reference signal index")
lines(alignment4$index1, alignment4$index2, type = "b", col = "blue")
legend("topleft",inset = c(0,0), legend = c("First chunk", "Second chunk"), col = c("red", "blue"), lty = 1)
library("dtw")
?stepPattern
?dtw
?ts
x = ts(seq(1,10))
y = ts(seq(2,15))
x = ts(seq(1,10))
y = ts(seq(2,15))
d = dist(x, y)
x = matrix(seq(1,10), nrow = 2, ncol = 5)
y = matrix(seq(1,10), nrow = 2, ncol = 5)
d = dist(x, y)
d
y = matrix(seq(1,10), nrow = 5, ncol = 2)
x = matrix(seq(1,10), nrow = 5, ncol = 2)
y = matrix(seq(1,10), nrow = 5, ncol = 2)
d = dist(x, y)
d
numBatches = 20
numPVs = 7
numPoints = 1000
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
start = Sys.time()
x = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
print(Sys.time() - start)
d = dist(x,x)
source('~/.active-rstudio-document', echo=TRUE)
numBatches = 20
numPVs = 7
numPoints = 1000
reference = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
start = Sys.time()
query = matrix(sample(x = seq(1,100), size = numPVs*numBatches, replace = TRUE), nrow = numPoints, ncol = numPVs)
D = dist(query, reference)
alignment = dtw(D, step.pattern = "symmetricP05")
source('~/.active-rstudio-document', echo=TRUE)
?dist
head(D)
type(D)
typeof(D)
classof(D)
class(D)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
D
?stepMatrix
??stepMatrix
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
ldist<-matrix(1,nrow=6,ncol=6);  # Matrix of ones
ldist[2,]<-0; ldist[,5]<-0;      # Mark a clear path of zeroes
ldist[2,5]<-.01;		 # Forcely cut the corner
ds<-dtw(ldist);			 # DTW with user-supplied local
#   cost matrix
da<-dtw(ldist,step=asymmetric);	 # Also compute the asymmetric
plot(ds$index1,ds$index2,pch=3); # Symmetric: alignment follows
#   the low-distance marked path
points(da$index1,da$index2,col="red");  # Asymmetric: visiting
#   1 is required twice
ds$distance;
da$distance;
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?stepPattern
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
queries[[1]]
queries[1]
source('~/.active-rstudio-document', echo=TRUE)
queries[[1]]
class(queries[1])
class(queries[[1]])
source('~/.active-rstudio-document', echo=TRUE)
query = queries[[1]]
D = dist(reference, query)
alignment = dtw(D, "symmetricP0")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?stepPattern
source('~/.active-rstudio-document', echo=TRUE)
stepPattern
dtw$stepPattern
source('~/.active-rstudio-document', echo=TRUE)
require('dtw')
print(symmetricP05)
plot(symmetric1)
?text
knitr::opts_chunk$set(echo = TRUE)
plot(symmetric1)
require("dtw")
plot(symmetric1)
text(-.5, 1, "P1")
text(-.5, 1, "P1")
plot(symmetric1)
text(-.5, 1, "P1")
plot(symmetric1)
text(-.5, 1, "P1")
plot(symmetric1)
require("dtw")
plot(symmetricP05)
print(symmetricP05)
a = matrix(c(1,2,3,4), nrow = 2)
b = matrix(c(0,1,5,6), nrow = 2)
a
b
min(a,b)
lapply(list(a,b), min)
plot(symmetric1)
?stepPattern
dtw::mvmStepPattern()
dtw
globalCostMatrix
dtw:::globalCostMatrix()
dtw:::globalCostMatrix
C_computeCM_Call
dtw:::C_computeCM_Call
source('~/.active-rstudio-document', echo=TRUE)
x = c(1,6,2,3,0,9,4,3,6,3)
y = c(1,3,4,9,8,2,1,5,7,3)
require(dtw)
alignment = dtw(x = x, y = y, step.pattern = symmetric1, keep.internals = TRUE)
ccm = alignment$costMatrix
image(x = 1:nrow(ccm), y = 1:ncol(ccm), ccm)
text(row(ccm), col(ccm), label = ccm)
library("dtw")
symmetricP05
library(dtw)
symmetric1
pgamma(0.1, 6,93.5)
30+3+16+8+114+60+4+23+30+105
qgamma(.975, 10, 393)
plotpost = function(y) {}
plotpost = function(y) {}
plotpost = function(y) {393^10*10/((393+y)^(10+1))}
plotpost(3)
curve(plotpost(x), from = 0, to = 120)
30+16+8+114+60+4+23+30+105
dataComplete = c(1024, 1045, 1025, 1133, 1038, 1097, 1081, 968, 1045, 1081, 1016, 1055, 957, 1079, 1104, 1082, 1021, 1100, 1056, 1079, 1087, 1126, 1716, 1335, 982, 1106, 1066, 1127, 1306, 1159, 940, 1324)
hist(dataComplete)
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
source('~/GitHub/pgdtw/sDTW/All plots.R', echo=TRUE)
